(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ReactDOM = factory());
})(this, (function () { 'use strict';

	//函数式组件
	const FunctionComponent = 0;
	//应用在宿主环境挂载的根节点
	const HostRoot = 3;
	//宿主组件
	const HostComponent = 5;
	//文本节点
	const HostText = 6;

	//0 -> 表示没有任何的副作用
	const NoFlags = 0b0000000;
	//2 -> 表示节点被插入
	const Placement = 0b0000010;
	//4 -> 表示节点被更新
	const Update = 0b0000100;
	//8 -> 表示子节点被删除
	const ChildDeletion = 0b0001000;
	const MutationMask = Placement | Update | ChildDeletion;

	class FiberNode {
	    tag;
	    key;
	    stateNode;
	    type;
	    return;
	    sibling;
	    child;
	    index;
	    ref;
	    pendingProps;
	    memorizedProps;
	    memorizedState;
	    alternate;
	    flags;
	    subtreeFlags;
	    updateQueue;
	    constructor(tag, pendingProps, key) {
	        //类型
	        this.tag = tag;
	        this.key = key;
	        this.ref = null;
	        //节点对应的实际 DOM 节点或者组件实例
	        this.stateNode = null;
	        //节点的类型（包括原生的 DOM 元素，类组件或者函数式组件）
	        this.type = null;
	        //树状结构
	        //节点的父节点
	        this.return = null;
	        //节点的下一个兄弟节点
	        this.sibling = null;
	        //节点的第一个子节点
	        this.child = null;
	        //索引
	        this.index = 0;
	        //作为工作单元
	        //节点的新属性 -> 用于在协调过程中进行更新
	        this.pendingProps = pendingProps;
	        //已经更新完的属性
	        this.memorizedProps = null;
	        //更新完成后新的state
	        this.memorizedState = null;
	        //节点的备份节点，用于在协调过程中进行比较
	        this.alternate = null;
	        //节点的副作用类型
	        this.flags = NoFlags;
	        //子节点的副作用类型，如更新，插入，删除等
	        this.subtreeFlags = NoFlags;
	        //更新计划队列
	        this.updateQueue = null;
	    }
	}
	//触发更新
	//更新 React 应用可以由多种触发方式引发，包括组件的状态变化、属性变化、父组件的重新渲染以及用户事件等等
	//先来处理创建 React 应用的根对象这种情况，也就是 ReactDOM.createRoot(rootElement).render(<App/>) 这条语句
	//ReactDOM.createRoot() 函数生成一个新的 Root 对象，它在源码中是 FiberRootNode 类型，充当了 React 应用的根节点
	//rootElement 则是要渲染到的 DOM 节点，它在源码中是 hostRootFiber 类型，作为 React 应用的根 DOM 节点
	//render() 方法将组件 <App/> 渲染到根节点上。在这个过程中，React 会创建一个代表 <App/> 组件的 FiberNode，并将其添加到 Root 对象的 Fiber 树上
	//实现 FiberRootNode 类
	class FiberRootNode {
	    //传入的 DOM 容器
	    container;
	    //指向当前 Fiber 树根节点 (hostRootFiber)
	    current;
	    //表示已经完成构建的 Fiber 树
	    finishedWork;
	    constructor(container, hostRootFiber) {
	        this.container = container;
	        this.current = hostRootFiber;
	        //将根节点的 stateNode 属性指向 FiberNodeRoot, 用于表示整个 React 的根节点
	        hostRootFiber.stateNode = this;
	        //指向更新完成之后的 hostRootFiber
	        this.finishedWork = null;
	    }
	}
	//根据 FiberRootNode.current 创建 workInProgress
	//在 "旧 Fiber 树" 的基础上构建或复用一颗 "工作树"
	const createWorkInProgress = (current, pendingProps) => {
	    let workInProgress = current.alternate;
	    if (workInProgress === null) {
	        //首屏渲染时，会从 root 节点从无到有创建一颗 workInProgress 树
	        workInProgress = new FiberNode(current.tag, pendingProps, current.key);
	        workInProgress.stateNode = current.stateNode;
	        //双缓存机制实现，实现状态缓存
	        workInProgress.alternate = current;
	        current.alternate = workInProgress;
	    }
	    else {
	        //非首屏渲染
	        workInProgress.pendingProps = pendingProps;
	        //将 effect 链表重置为空
	        workInProgress.flags = NoFlags;
	        workInProgress.subtreeFlags = NoFlags;
	    }
	    //复制当前节点的大部分属性
	    workInProgress.type = current.type;
	    workInProgress.updateQueue = current.updateQueue;
	    workInProgress.child = current.child;
	    workInProgress.memorizedState = current.memorizedState;
	    workInProgress.memorizedProps = current.memorizedProps;
	    return workInProgress;
	};
	//从 React 元素 (如 <div /> 或者函数组件) 创建 Fiber 节点
	//通常在初次挂载 Fiber 树时调用
	function createFiberFromElement(element) {
	    //解构 type, key, props
	    //type: 元素类型，可以是字符串 ('div')，也可以是函数组件或者类组件
	    const { type, key, props } = element;
	    //默认是函数组件
	    let fiberTag = FunctionComponent;
	    if (typeof type === 'string') {
	        //字符串 --> 原生 DOM 元素
	        fiberTag = HostComponent;
	    }
	    else if (typeof type !== 'function' && true) {
	        console.warn('未定义的 type 类型', element);
	    }
	    //创建新的 FiberNode 实例
	    const fiber = new FiberNode(fiberTag, props, key);
	    fiber.type = type;
	    return fiber;
	}

	//实现更新机制
	//updateQueue 是一个队列，用来存储组件的更新操作
	//当组件的状态发生变化时，会生成一个新的 update 对象，并将其添加到组件的 updateQueue 中
	//更新队列通常是以链表的形式实现的，每个 update 对象都连接到下一个更新对象，形成一个更新链表。在 React 的更新过程中，会遍历更新队列，并根据其中的更新操作来更新组件的状态以及更新 DOM
	//创建 update 实例
	const createUpdate = (action) => {
	    return {
	        action
	    };
	};
	//创建 updateQueue 实例
	//pending 初始化为 null，表示没有待处理的更新
	const createUpdateQueue = () => {
	    return {
	        shared: {
	            pending: null
	        },
	        dispatch: null
	    };
	};
	//将 update 添加到 updateQueue 中
	const addQueueUpdate = (updateQueue, update) => {
	    updateQueue.shared.pending = update;
	};
	//从 updateQueue 中消费 update 的方法
	const processUpdateQueue = (baseState, pendingUpdate) => {
	    //初始化结果
	    const result = {
	        memorizedState: baseState
	    };
	    //如果有待处理的更新，则取出 action
	    if (pendingUpdate !== null) {
	        const action = pendingUpdate.action;
	        //如果 action 是回调函数，(baseState = 1, update = (i) => 5 * i) --> memorizedState = 5
	        if (action instanceof Function) {
	            result.memorizedState = action(baseState);
	        }
	        else {
	            //如果 action 是状态值，(baseState = 1, update = 2) --> memorizedState = 2
	            result.memorizedState = action;
	        }
	    }
	    return result;
	};

	//检查 Symbol 是否是一个函数 (在支持 ES6 的环境中是一个函数)
	//Symbol.for 是一个静态方法，用于创建或访问一个全局注册的 symbol
	const supportSymbol = typeof Symbol === 'function' && Symbol.for;
	// 表示普通的 React 元素，即通过 JSX 创建的组件或 DOM 元素
	const REACT_ELEMENT_TYPE = supportSymbol
	    ? Symbol.for('react.element')
	    : 0xeac7;

	//reconcileChildren 函数中调用了 reconcileChildFibers 和 mountChildFibers 两个函数，它们分别负责处理更新阶段和首次渲染阶段的子节点协调
	//reconcileChildFibers:
	//reconcileChildFibers 函数作用于组件的更新阶段，即当组件已经存在于 DOM 中，需要进行更新时
	//主要任务是协调处理当前组件实例的子节点，对比之前的子节点（current）和新的子节点（workInProgress）之间的变化
	//根据子节点的类型和 key 进行对比，决定是复用、更新、插入还是删除子节点，最终形成新的子节点链表
	//根据参数 shouldTrackSideEffects 控制是否追踪副作用 (如 DOM 插入操作)
	//true: 更新阶段 false: 初次挂载 (所有节点都被插入)
	function ChildReconciler(shouldTrackSideEffects) {
	    //处理单个 Element 节点的情况
	    //对比 current Fiber 与 ReactElement
	    //生成 workInProgress FiberNode
	    function reconcileSingleElement(returnFiber, currentFiber, element) {
	        //returnFiber: 当前正在处理的父 Fiber
	        //currentFiber: 之前的子节点
	        //element: 当前 ReactElement
	        const fiber = createFiberFromElement(element);
	        fiber.return = returnFiber;
	        return fiber;
	    }
	    //处理文本节点
	    function reconcileSingleTextNode(returnFiber, currentFiber, content) {
	        const fiber = new FiberNode(HostText, { content }, null);
	        fiber.return = returnFiber;
	        return fiber;
	    }
	    //为 Fiber 节点添加更新的 flags
	    function placeSingleChild(fiber) {
	        //当首屏渲染且追踪副作用时，才会添加更新 flags
	        if (shouldTrackSideEffects && fiber.alternate === null) {
	            fiber.flags |= Placement;
	        }
	        return fiber;
	    }
	    //根据 shouldTrackSideEffects 返回不同的 reconcileChildFibers 实现
	    return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
	        //判断当前 fiber 类型
	        //单个 Element 节点
	        if (typeof newChild === 'object' && newChild !== null) {
	            switch (newChild.$$typeof) {
	                case REACT_ELEMENT_TYPE:
	                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
	                default:
	                    {
	                        console.warn('未实现的 reconcile 类型', newChild);
	                    }
	                    break;
	            }
	        }
	        //多个 Element 节点
	        if (Array.isArray(newChild)) {
	            {
	                console.warn('未实现的 reconcile 类型', newChild);
	            }
	        }
	        //文本节点
	        if (typeof newChild === 'string' || typeof newChild === 'number') {
	            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
	        }
	        {
	            console.warn('未实现的 reconcile 类型', newChild);
	        }
	        return null;
	    };
	}
	//组件的更新阶段中，追踪副作用
	const reconcileChildFibers = ChildReconciler(true);
	//首屏渲染阶段中不追踪副作用，只对根节点进行一次 DOM 插入操作
	const mountChildFibers = ChildReconciler(false);

	//根据 Fiber 节点的类型 (HostRoot, HostComponent, HostText) 分发任务给不同的处理函数，处理具体节点类型的更新逻辑
	//HostRoot: 表示根节点，即应用的最顶层节点
	//调用 updateHostRoot 函数，处理根节点的更新，包括协调处理根节点的属性以及子节点的更新逻辑
	//调用 reconcileChildren 函数，处理根节点的子节点，可能会递归调用其他协调函数
	//返回 workInProgress.child 表示经过协调后的新的子节点链表
	//比较并返回子 FiberNode
	const beginWork = (workInProgress) => {
	    switch (workInProgress.tag) {
	        case HostRoot:
	            //表示根节点，即应用的最顶层节点
	            return updateHostRoot(workInProgress);
	        case HostComponent:
	            //表示原生 DOM 元素
	            return updateHostComponent(workInProgress);
	        //表示函数组件
	        case FunctionComponent:
	            return updateFunctionComponent(workInProgress);
	        case HostText:
	            //表示文本节点
	            return updateHostText();
	        default:
	            {
	                console.warn('beginWork 未实现的类型', workInProgress.tag);
	            }
	            return null;
	    }
	};
	//根据当前节点和工作中节点的状态进行比较，处理属性等更新逻辑
	function updateHostRoot(workInProgress) {
	    //状态初始化
	    //此时 memorizedState 是上一次计算后的状态，把它作为初始状态
	    const baseState = workInProgress.memorizedState;
	    //获取更新队列 updateQueue，记录了待处理的状态更新
	    const updateQueue = workInProgress.updateQueue;
	    //从更新队列中提取待处理的更新链表
	    const pending = updateQueue.shared.pending;
	    //清空更新队列，表示这些更新即将被处理
	    updateQueue.shared.pending = null;
	    //计算待更新状态的最新值
	    //将 pending 中的更新应用到新的 baseState 上，生成新的状态
	    const { memorizedState } = processUpdateQueue(baseState, pending);
	    //将 memorizedState 赋值给当前 workInProgress 上
	    workInProgress.memorizedState = memorizedState;
	    //处理子节点的更新逻辑
	    const nextChildren = workInProgress.memorizedState;
	    reconcileChildren(workInProgress, nextChildren);
	    return workInProgress.child;
	}
	function updateHostComponent(workInProgress) {
	    //从 Fiber 节点中获取即将使用的属性 pendingProps
	    //属性来自 React 最新一次渲染提交的 DOM
	    //eg: <div id="app" className="main">hello</div>
	    //pendingProps 为: {id: "app", className: "main", children: "hello"}
	    const nextProps = workInProgress.pendingProps;
	    //提取 children
	    const nextChildren = nextProps.children;
	    reconcileChildren(workInProgress, nextChildren);
	    return workInProgress.child;
	}
	function updateHostText() {
	    //没有子节点，返回 null
	    return null;
	}
	//updateFunctionComponent函数会调用函数组件本身来获取其返回的 React 元素树
	//eg: function App() {
	//     return {
	//        123;
	//    }
	// }
	//只需要调用 App() 就可以得到其子节点，从而将子节点传给 reconcileChildren 协调处理子节点的更新逻辑
	//eg: function App() {
	//   const [count, setCount] = useState(0)
	//   return <div>{count}</div>
	//}
	//1: 首先会调用 renderWithHooks 执行 App() 得到 <div>{count}</div>
	//2: 将 JSX 转化为虚拟 DOM 节点
	//3: 调用 reconcileChildren 开始对比新旧 Fiber 树，准备生成新的 Fiber 子节点
	//4: 返回第一个子节点供调度器继续向下构建 Fiber 树
	function updateFunctionComponent(workInProgress) {
	    const nextChildren = renderWithHooks(workInProgress);
	    reconcileChildren(workInProgress, nextChildren);
	    return workInProgress.child;
	}
	//执行函数组件中的函数
	function renderWithHooks(workInProgress) {
	    //保存在 type 字段中
	    const Component = workInProgress.type;
	    const props = workInProgress.pendingProps;
	    //执行函数
	    const children = Component(props);
	    return children;
	}
	//对比子节点的 current FiberNode 与子节点的 ReactElement
	//生成子节点对应的 workInProgress FiberNode
	function reconcileChildren(workInProgress, children) {
	    const current = workInProgress.alternate;
	    if (current !== null) {
	        //组件的更新阶段
	        workInProgress.child = reconcileChildFibers(workInProgress, current?.child, children);
	    }
	    else {
	        //首屏渲染阶段
	        workInProgress.child = mountChildFibers(workInProgress, null, children);
	    }
	}

	const createInstance = (type, props) => {
	    // TODO: 处理 props
	    const element = document.createElement(type);
	    return element;
	};
	const appendInitialChild = (parent, child) => {
	    parent.appendChild(child);
	};
	const createTextInstance = (content) => {
	    const element = document.createTextNode(content);
	    return element;
	};
	const appendChildToContainer = (child, parent) => {
	    parent.appendChild(child);
	};

	//completeWork 根据 Fiber 节点类型构建 DOM 节点，收集更新 flags, 并且根据更新 flags 执行不同的 DOM 操作
	//HostRoot:
	//表示根节点
	//会执行一些与根节点相关的最终操作，例如处理根节点的属性，确保整个应用更新完毕
	//HostComponent:
	//表示原生 DOM 节点
	//构建 DOM 节点，并调用 appendAllChildren 函数将 DOM 插入到 DOM 树上，收集更新 flags，并根据更新的 flags 执行不同的 DOM 操作，例如插入新节点，更新节点属性，删除节点等
	//HostText:
	//表示文本节点
	//构建 DOM 节点，并将 DOM 插入到 DOM 树上
	//收集更新 flags，根据 flags 的值，更新文本节点的内容
	//生成更新计划，计算和收集更新 flags
	const completeWork = (workInProgress) => {
	    const newProps = workInProgress.pendingProps;
	    const current = workInProgress.alternate;
	    switch (workInProgress.tag) {
	        case HostRoot:
	        case FunctionComponent:
	            bubbleProperties(workInProgress);
	            return null;
	        case HostComponent:
	            if (current !== null && workInProgress.stateNode !== null) ;
	            else {
	                //首屏渲染阶段
	                //创建新的 DOM 元素, eg: document.createElement('div')
	                const instance = createInstance(workInProgress.type);
	                //将 DOM 插入到 DOM 树中
	                appendAllChildren(instance, workInProgress);
	                workInProgress.stateNode = instance;
	            }
	            //收集更新 flags
	            bubbleProperties(workInProgress);
	            return null;
	        case HostText:
	            if (current !== null && workInProgress.stateNode !== null) ;
	            else {
	                //首屏渲染阶段
	                //构建 DOM 元素
	                const instance = createTextInstance(newProps.content);
	                workInProgress.stateNode = instance;
	            }
	            //收集更新 flags
	            bubbleProperties(workInProgress);
	            return null;
	        default:
	            {
	                console.warn('completeWork 未实现的类型', workInProgress);
	            }
	            return null;
	    }
	};
	//appendAllChildren 函数负责递归的将组件的子节点添加到指定的 parent 中，通过深度优先遍历遍历 workInProgress 的子节点链表, 处理每个子节点的类型
	//先处理当前节点的所有子节点，再处理兄弟节点
	//如果为原生 DOM 元素节点或者文本节点，则将其添加到父节点中
	//如果是其他类型的组件节点并且有子节点，则递归处理子节点
	function appendAllChildren(parent, workInProgress) {
	    let node = workInProgress.child;
	    while (node !== null) {
	        if (node.tag === HostComponent || node.tag === HostText) {
	            //处理原生 DOM 元素或者文本节点
	            appendInitialChild(parent, node.stateNode);
	        }
	        else if (node.child !== null) {
	            //递归处理其他类型的组件节点的子节点
	            node.child.return = node;
	            node = node.child;
	            continue;
	        }
	        //如果返回到最深层的节点，说明处理完毕
	        if (node === workInProgress) {
	            return;
	        }
	        //如果当前节点没有兄弟节点，说明已处理完，需要向上返回父节点寻找下一个兄弟节点
	        while (node.sibling === null) {
	            //如果已经回到根节点或者没有父节点，就结束遍历
	            if (node.return === null || node.return === workInProgress) {
	                return;
	            }
	            node = node.return;
	        }
	        //处理下一个兄弟节点
	        node.sibling.return = node.return;
	        node = node.sibling;
	    }
	}
	//bubbleProperties 函数负责在 completeWork 函数向上遍历的过程中，通过向上冒泡子节点的 flags，将所有更新 flags 收集到根节点
	//从当前需要冒泡属性的 Fiber 节点开始，检查是否有需要冒泡的属性。如果当前节点有需要冒泡的属性，将这些属性冒泡到父节点的 subtreeFlags 或者其他适当的属性中
	//递归调用 bubbleProperties 函数，处理父节点，将属性继续冒泡到更上层的祖先节点，直至达到根节点
	function bubbleProperties(workInProgress) {
	    //累加节点所有子树的 flags
	    let subtreeFlags = NoFlags;
	    let child = workInProgress.child;
	    //遍历兄弟节点
	    while (child !== null) {
	        subtreeFlags |= child.subtreeFlags;
	        subtreeFlags |= child.flags;
	        //建立父子节点关系
	        child.return = workInProgress;
	        child = child.sibling;
	    }
	    //把累加的子树 subtreeFlags 传入当前的 workInProgress 中
	    workInProgress.subtreeFlags |= subtreeFlags;
	}

	//commitMutationEffects 函数负责深度优先遍历 Fiber 树，递归向下寻找子节点是否存在 Mutation 阶段需要执行的 Flags
	//如果遍历到某个节点，其所有的子节点都不存在 Flags，则停止向下，调用 commitMutationEffectsOnFiber 处理该节点的 Flags, 之后开始遍历其兄弟节点和父节点
	//commitMutationEffectsOnFiber 会根据每个节点的 Flags 和更新计划中的信息执行相应的 DOM 操作
	//记录遍历时当前正在处理的 Fiber 节点
	let nextEffect = null;
	//Mutation 阶段，提交 HostComponent 的副作用
	const commitMutationEffects = (finishedWork) => {
	    nextEffect = finishedWork;
	    //深度优先遍历 Fiber 树，寻找更新 Flags
	    while (nextEffect !== null) {
	        //向下遍历
	        const child = nextEffect.child;
	        //如果有子节点并且子节点存在 Mutation 阶段需要执行的 Flags
	        if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags &&
	            child !== null) {
	            nextEffect = child;
	        }
	        else {
	            //子节点不存在或者子节点不存在 Mutation 阶段需要执行的 Flags
	            //向上遍历
	            up: while (nextEffect !== null) {
	                //处理 Flags
	                commitMutationEffectOnFiber(nextEffect);
	                const sibling = nextEffect.sibling;
	                //遍历兄弟节点
	                if (sibling !== null) {
	                    nextEffect = sibling;
	                    break up;
	                }
	                //遍历父节点
	                nextEffect = nextEffect.return;
	            }
	        }
	    }
	};
	//遍历 Fiber 树，处理 Flags
	const commitMutationEffectOnFiber = (finishedWork) => {
	    const flags = finishedWork.flags;
	    //位运算
	    //判断该节点是否包含副作用
	    if ((flags & Placement) !== NoFlags) {
	        commitPlacement(finishedWork);
	        //清除该副作用标志
	        finishedWork.flags &= -3;
	    }
	    if ((flags & Update) !== NoFlags) {
	        finishedWork.flags &= -5;
	    }
	    if ((flags & ChildDeletion) !== NoFlags) {
	        finishedWork.flags &= -9;
	    }
	};
	//执行 DOM 插入操作，将 FiberNode 对应的 DOM 插入到 parent DOM 中
	const commitPlacement = (finishedWork) => {
	    //开发模式
	    {
	        console.log('执行 Placement 操作', finishedWork);
	    }
	    //查找一个对应实际 DOM 的节点
	    const hostParent = getHostParent(finishedWork);
	    if (hostParent !== null) {
	        appendPlacementNodeIntoContainer(finishedWork, hostParent);
	    }
	};
	//获取 parent DOM
	const getHostParent = (fiber) => {
	    let parent = fiber.return;
	    while (parent !== null) {
	        const parentTag = parent.tag;
	        //处理 root 节点
	        if (parentTag === HostRoot) {
	            return parent.stateNode.container;
	        }
	        //处理原生 DOM 节点
	        if (parentTag === HostComponent) {
	            return parent.stateNode;
	        }
	        else {
	            parent = parent.return;
	        }
	    }
	    {
	        console.log('未找到 host parent', fiber);
	    }
	    return null;
	};
	//遍历子节点，将子节点的 DOM 插入到 parent DOM 中
	const appendPlacementNodeIntoContainer = (finishedWork, hostParent) => {
	    if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
	        //插入到 parent DOM 中
	        appendChildToContainer(finishedWork.stateNode, hostParent);
	    }
	    else {
	        const child = finishedWork.child;
	        if (child !== null) {
	            appendPlacementNodeIntoContainer(child, hostParent);
	            //处理子节点的兄弟节点
	            let sibling = child.sibling;
	            while (sibling !== null) {
	                appendPlacementNodeIntoContainer(sibling, hostParent);
	                sibling = sibling.sibling;
	            }
	        }
	    }
	};

	/* eslint-disable no-constant-condition */
	//实现 Reconciler 的更新流程
	//具体流程
	//1: 遍历 Fiber 树: React 使用 DFS 来遍历 Fiber 树，首先会从 Fiber 树的根节点开始遍历，遍历整棵树的结构
	//2: 比较新旧节点: 对于每个 Fiber 节点，Reconciler 会比较新节点(React Element) 和旧节点(现有的 FiberNode) 之间的差异，比较内容包括节点类型，属性，子节点等差异
	//3: 生成更新计划: 根据比较结果，Reconciler 会生成一个更新计划，用于确定需要进行的操作。更新计划通常包括哪些节点需要更新，哪些节点需要插入到 DOM 中，哪些节点需要删除等信息
	//4: 打标记: 为了记录不同节点的操作，React 会为每个节点打上不同的标记。例如，如果节点需要更新，可能会打上更新标记（Update Tag）；如果节点是新创建的，可能会打上插入标记（Placement Tag）；如果节点被移除，可能会打上删除标记（Deletion Tag）等
	//5: 更新 Fiber 节点:  根据生成的更新计划和标记，Reconciler 会更新对应的 Fiber 节点以反映组件的最新状态
	//6: 递归处理子节点: 对于每个节点的子节点，React 会递归地重复进行上述的比较和更新操作，以确保整个组件树都得到了正确的处理
	//当所有 React Element 都比较完成之后，会生成一棵新的 Fiber 树，此时，一共存在两棵 Fiber 树:
	//current: 与视图中真实 UI 对应的 Fiber 树，当 React 开始新的一轮渲染时，会使用 current 作为参考来比较新的树与旧树的差异，决定如何更新 UI
	//workInProgress: 触发更新后，正在 Reconciler 中计算的 Fiber 树，一旦 workInProgress 上的更新完成，它将会被提交为新的current，成为下一次渲染的参考树，并清空旧的 current 树
	//current Fiber 树中的 Fiber 节点被称为 current fiber, workInProgress Fiber 树中的 Fiber 节点被称为 workInProgress fiber
	//通过 alternate 属性来连接，即
	//currentFiber.alternate === workInProgressFiber | workInProgressFiber.alternate === currentFiber
	let workInProgress = null;
	//提交阶段的主要任务是将更新同步到实际的 DOM 中，执行 DOM 操作，例如创建、更新或删除 DOM 元素，反映组件树的最新状态，可以分为三个主要的子阶段
	//1: Before Mutation (布局阶段)：主要用于执行 DOM 操作之前的准备工作，包括类似 getSnapshotBeforeUpdate 生命周期函数的处理
	//2: Mutation (DOM 操作阶段)：执行实际 DOM 操作的阶段，包括创建、更新或删除 DOM 元素等。使用深度优先遍历的方式，逐个处理 Fiber 树中的节点，根据协调阶段生成的更新计划，执行相应的 DOM 操作
	//3: Layout (布局阶段)：用于处理布局相关的任务，进行一些布局的优化，比如批量更新布局信息，减少浏览器的重排（reflow）次数，提高性能
	//实现 commitRoot 函数 -- 即开始提交阶段的入口函数
	//commitRoot 函数会判断根节点的 flags 和 subtreeFlags 是否存在上述三个阶段需要执行的操作，如果有则执行 commitMutationEffects 函数从而完成 Fiber 树的替换
	//因为 current 是与视图中真实 UI 对应的 Fiber 树，而 workInProgress 是触发更新后正在 Reconciler 中计算的 Fiber 树，因此在 DOM 操作执行完之后，需要将 current 指向 workInProgress，完成 Fiber 树的切换
	function renderRoot(root) {
	    prepareFreshStack(root);
	    //开始执行主循环
	    //如果中间某个节点处理有错误，打印警告，并把 workInProgress 清空，防止挂死
	    do {
	        try {
	            workLoop();
	            break;
	        }
	        catch (e) {
	            console.warn('workLoop 发生错误: ', e);
	            workInProgress = null;
	        }
	    } while (true);
	    //创建根 Fiber 树的 Root Fiber
	    //将已经构建完成的 workInProgress 树赋值给 finishedWork
	    const finishedWork = root.current.alternate;
	    //将构建完成的新树挂载到根节点上
	    root.finishedWork = finishedWork;
	    //提交阶段的入口函数
	    commitRoot(root);
	}
	function commitRoot(root) {
	    const finishedWork = root.finishedWork;
	    if (finishedWork === null) {
	        return;
	    }
	    //开发环境
	    {
	        console.log('commit 阶段开始');
	    }
	    //重置 -- 目的是防止重复提交
	    root.finishedWork = null;
	    //判断是否存在3个子阶段需要执行的操作
	    const subtreeHasEffects = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
	    const rootHasEffects = (finishedWork.flags & MutationMask) !== NoFlags;
	    if (subtreeHasEffects || rootHasEffects) {
	        //Mutation
	        commitMutationEffects(finishedWork);
	        //Fiber 树切换，current 变成 workInProgress
	        root.current = finishedWork;
	    }
	    else {
	        root.current = finishedWork;
	    }
	}
	//初始化 workInProgress 变量
	//直接把 workInProgress 设置成当前要渲染的 root 根节点
	function prepareFreshStack(root) {
	    workInProgress = createWorkInProgress(root.current, {});
	}
	//DFS
	//向下递归子节点
	function workLoop() {
	    while (workInProgress !== null) {
	        performUnitOfWork(workInProgress);
	    }
	}
	function performUnitOfWork(fiber) {
	    //比较并返回子 FiberNode
	    //开始工作 --> 负责构建表示更新的 Fiber 树
	    const next = beginWork(fiber);
	    //更新节点的新属性
	    fiber.memorizedProps = fiber.pendingProps;
	    if (next === null) {
	        //如果当前没有子节点，则遍历兄弟节点或者父节点
	        completeUnitOfWork(fiber);
	    }
	    else {
	        //如果当前有子节点，则继续向下进行深度遍历
	        workInProgress = next;
	    }
	}
	function completeUnitOfWork(fiber) {
	    //从当前节点开始
	    let node = fiber;
	    do {
	        //生成更新计划 --> 将 Fiber 树映射到实际的 DOM 结构
	        completeWork(node);
	        //如果有兄弟节点，则遍历兄弟节点
	        const sibling = node.sibling;
	        if (sibling !== null) {
	            workInProgress = sibling;
	            return;
	        }
	        //否则向上返回, 遍历父节点
	        node = node.return;
	        //workInProgress 最终指向根节点
	        workInProgress = node;
	    } while (node !== null);
	}
	//调度功能
	function scheduleUpdateOnFiber(fiber) {
	    const root = markUpdateFromFiberToRoot(fiber);
	    //渲染根节点
	    renderRoot(root);
	}
	//从当前的 fiber 节点开始，向上查找根节点，然后从根节点开始 render 流程
	function markUpdateFromFiberToRoot(fiber) {
	    let node = fiber;
	    while (node.return !== null) {
	        node = node.return;
	    }
	    if (node.tag === HostRoot) {
	        return node.stateNode;
	    }
	    return null;
	}
	//eg: 对于下面的组件，render 阶段会依次执行
	//function App() {
	//	return (
	//		<div>
	//			Hello
	//			<span>World</span>
	//		</div>
	//	);
	//}
	//HostRootFiber beginWork(生成 App FiberNode) -> App fiberNode beginWork(生成 div fiberNode) -> div fiberNode beginWork(生成 'Hello' 以及 span fiberNode)
	// -> 'Hello' fiberNode beginWork(叶子元素) -> 'Hello' fiberNode completeWork -> span fiberNode beginWork(叶子元素) -> span fiberNode completeWork
	// -> div fiberNode completeWork -> App fiberNode completeWork -> HostRootFiber completeWork

	function createContainer(container) {
	    //创建一个新的 FiberNode 对象，该对象表示根节点
	    const hostRootFiber = new FiberNode(HostRoot, {}, null);
	    //创建一个新的 FiberRootNode 对象，该对象用于管理整个 React 应用的状态以及更新
	    const root = new FiberRootNode(container, hostRootFiber);
	    hostRootFiber.updateQueue = createUpdateQueue();
	    return root;
	}
	function updateContainer(element, root) {
	    //获取根节点的 current 属性，该属性表示当前正在渲染的 Fiber 节点
	    const hostRootFiber = root.current;
	    //创建一个 update 对象，用于存储新的 React 元素
	    const update = createUpdate(element);
	    //将 update 加入到 updateQueue 中
	    addQueueUpdate(hostRootFiber.updateQueue, update);
	    //协调更新
	    scheduleUpdateOnFiber(hostRootFiber);
	    return element;
	}
	//总结 React 应用在首次渲染或后续更新时的大致更新流程:
	//1: 通过 createContainer 函数创建了 React 应用的根节点 FiberRootNode, 并将其与 DOM 节点 (hostFiberRoot) 连接起来
	//2: 通过 updateContainer 函数创建了一个更新 update，并将其加入到更新队列 (updateQueue) 中，启动了首屏渲染或者后续更新的机制
	//3: 调用 scheduleUpdateOnFiber 函数开始调度更新，从触发更新的节点开始向上遍历，直到达到根节点 FiberRootNode
	//4: 调用 renderRoot 函数，初始化 workInProgress 变量，生成与 hostRootFiber 对应的 workInProgress hostRootFiber
	//5: 开始 Reconciler 的更新流程，即 workLoop 函数，对 Fiber 树进行深度优先遍历
	//6: 在向下遍历阶段会调用 beginWork 方法，在向上返回阶段会调用 completeWork 方法，这两个方法负责 Fiber 节点的创建、更新和处理

	//实现 React 首屏渲染流程
	//通过 ReactDOM.createRoot(root).render(<App />)方法，创建 React 应用的根节点，将一个 Placement 加入到更新队列中，并触发了首屏渲染的更新流程
	//在对 Fiber 树进行深度优先遍历 (DFS) 的过程中，比较新旧节点，生成更新计划，执行 DOM 操作，最终将 <App /> 渲染到根节点上
	//实现 ReactDOM.createRoot(root).render(<App />)
	function createRoot(container) {
	    const root = createContainer(container);
	    return {
	        render(element) {
	            updateContainer(element, root);
	        }
	    };
	}

	var ReactDOM = /*#__PURE__*/Object.freeze({
		__proto__: null,
		createRoot: createRoot
	});

	return ReactDOM;

}));
